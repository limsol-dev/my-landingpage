{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서(PRD)\n\n## 1. 개요\n본 프로젝트는 펜션 예약 웹서비스로, 사용자가 다양한 펜션‧부가 프로그램(바비큐, 조식, 레저 등)을 자유롭게 선택해 예약할 수 있도록 한다. 서비스는 고객용 웹, 모임장용 관리 콘솔, 운영자용 관리자 페이지로 구성되며, 경쟁 서비스인 `야놀자`, `여기어때` 대비 세분화된 프로그램 선택과 실시간 대시보드를 주요 차별점으로 한다.\n\n## 2. 문제 정의\n1. 기존 플랫폼은 ‘객실 단위’ 예약이 중심으로, 부가 프로그램 선택이 제한적이다.  \n2. 소규모 모임·파티 고객은 일정·인원·부가 옵션을 통합 관리하기 어렵다.  \n3. 펜션 운영자는 예약 현황, 정산, 고객 관리 기능이 파편화되어 업무 효율이 떨어진다.\n\n## 3. 목표 및 목적\n- 1차 목표: 사용자가 펜션 객실과 부가 프로그램을 한번에 예약·결제\n- 2차 목표: 운영자가 실시간 예약, 매출, 객실·프로그램 재고를 대시보드로 확인\n- 성공 지표  \n  - 예약 전환율 5% 이상  \n  - 프로그램(옵션) 추가 선택률 30% 이상  \n  - 관리자 페이지 일간 활성 사용자(DAU) 90% 이상  \n  - 서버 응답시간 P95 1초 이하  \n\n## 4. 타깃 사용자\n### 1) 주요 사용자\n- 일반 여행객: 20~40대, 모바일 친화, 개인·커플 여행\n- 모임장: 동호회·MT·워크샵 주관, 10~50인 규모, 일정·인원 변경 잦음\n### 2) 이해관계자\n- 펜션 운영자: 객실·프로그램·정산 관리\n- 제휴업체: 레저·바비큐·조식 서비스 공급\n- 플랫폼 운영팀: CS, 매출 분석, 마케팅\n\n## 5. 사용자 스토리\n- 여행객으로서, 다양한 부가 프로그램을 한 화면에서 선택해 맞춤형 여행을 계획하고 싶다.  \n- 모임장으로서, 여러 객실을 동시에 예약하고 인원 정보를 일괄 입력하고 싶다.  \n- 운영자로서, 실시간 예약 현황을 대시보드로 파악해 인원·재고를 최적화하고 싶다.  \n- 제휴업체로서, 내 프로그램 예약 현황을 확인하고 자동 정산 보고서를 받고 싶다.  \n\n## 6. 기능 요구사항\n### 6.1 핵심 기능\n1. 객실·프로그램 통합 예약\n   - 객실, 날짜, 인원 입력 → 연동 프로그램 리스트 자동 필터링\n   - 수량·시간대 조건부 선택\n   - 결제 전 요금 상세 비교\n   - 승인조건: 모든 필수 입력 완료 시 ‘예약하기’ 버튼 활성화\n2. 부가 서비스 모듈\n   - 바비큐, 조식, 레저, 장보기 등 카테고리\n   - 프로그램별 재고·시간대 실시간 체크\n   - 관리자 CRUD API 연동\n3. 로그인·회원 시스템\n   - 이메일·SNS(OAuth2) 로그인\n   - JWT 세션, 비밀번호 재설정, 휴대폰 인증\n4. 마이페이지\n   - 예약 내역, 결제 영수증, 환불 요청\n   - 프로그램 일정 변경, 합산 결제 금액 자동 업데이트\n5. 예약자 전용 관리자(모임장 모드)\n   - 다중 객실·프로그램 수정\n   - 참여자 리스트 CSV 업로드, 자동 알림\n6. 운영자 대시보드\n   - 실시간 예약 건수, 매출, 객실 가용률 그래프\n   - 프로그램별 판매분석, 정산 리포트 다운로드\n   - 역할별 권한(Role-based Access Control)\n\n### 6.2 지원 기능\n- 자동 SMS/카카오 알림봇: 예약 확정, 체크인 1일 전, 프로그램 변경 시 발송\n- 프로모션·쿠폰 엔진: 할인 코드 생성, 조건부 적용\n- 다국어(한국어·영어) 인터페이스\n\n## 7. 비기능 요구사항\n- 성능: P95 페이지 로딩 < 1.5초, 동시 접속 5,000\n- 보안: OAuth2, TLS 1.3, 개인정보 AES256 암호화, OWASP Top10 차단\n- 사용성: 모바일 최적화(Responsive), 접근성 WCAG 2.1 AA\n- 확장성: 멀티펜션 SaaS 모델 대비 수평 확장 구조\n- 호환성: Chrome, Safari, Edge 최신 2버전, iOS/Android WebView 지원\n\n## 8. 기술 고려사항\n- 프론트엔드: Next.js 14(App Router, Server Actions), TypeScript, Tailwind CSS\n- 백엔드: Supabase(PostgreSQL, Auth, Storage), Edge Functions\n- 실시간: Supabase Realtime, WebSocket 기반\n- 인프라: Vercel + Cloudflare, AWS S3 Backup\n- 서드파티: 아임포트 결제, 카카오톡 비즈메시지, Google Analytics 4\n- 데이터 모델링\n  - tables: rooms, programs, reservations, payments, users, partners\n  - 관계형 설계, row-level security\n\n## 9. 성공 지표\n- 예약 생성/방문 세션 대비 5% 이상\n- 프로그램 옵션 평균 1.5개 이상 선택\n- 재방문율 25% 이상\n- CS 티켓/예약 1,000건당 3건 이하\n- 서버 오류율 0.1% 이하\n\n## 10. 일정 및 마일스톤\n| 단계 | 기간 | 주요 산출물 |\n|---|---|---|\n| 0. 기획 완료 | D+0 | PRD 확정, 와이어프레임 |\n| 1. MVP 개발 | D+1~D+60 | 객실 예약, 로그인, 결제, 기본 관리자 |\n| 2. 베타 테스트 | D+61~D+75 | 리포트, 버그 수정 |\n| 3. 공식 런치 | D+90 | 마케팅, SLA 모니터링 |\n| 4. 고도화 | D+91~D+150 | 자동 SMS, 쿠폰, 다국어 |\n\n## 11. 위험 및 완화\n- 결제 실패율↑ → 다중 결제사(카카오페이, 네이버페이) 추가, 재시도 로직\n- 실시간 재고 충돌 → 행 수준 잠금, 트랜잭션 처리, 중복 확인 API\n- 프로그램 공급 부족 → 제휴업체 계약, 가용 재고 기준 알림\n- 사용자 유입 저조 → 인플루언서·모임 특화 프로모션 실행\n\n## 12. 향후 고려사항\n- B2B 기업 전용 화상회의·워크샵 패키지\n- AI 기반 수요 예측으로 가격·프로그램 동적 추천\n- 모바일 앱(React Native) 출시\n- 펜션 외 글램핑·캠핑장 확장 SaaS 모델 확대",
      "writedAt": "2025-07-14T15:22:24.477Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  웹 기반 펜션 예약 서비스로, 고객용 웹, 모임장 전용 콘솔, 운영자 관리자 페이지로 구성됩니다. Next.js 14를 사용한 SSR/ISR과 Supabase(PostgreSQL, Auth, Storage, Edge Functions)를 결합하여 빠르고 확장 가능한 풀스택 구조를 채택합니다.  \n- **핵심 기술 스택**  \n  Frontend: Next.js 14, TypeScript, Tailwind CSS  \n  Backend: Supabase(PostgreSQL, Auth, Storage, Realtime, Edge Functions)  \n  Infra: Vercel, Cloudflare CDN, AWS S3 백업  \n  Third-Party: I’mport 결제, 카카오톡 비즈메시지, Google Analytics 4  \n- **주요 기술 목표**  \n  · P95 응답시간 1초 이하· 동시 접속자 5,000명 지원· RLS 기반 보안· 수평 확장 구조  \n- **핵심 가정 사항**  \n  · Supabase Edge Functions가 모든 커스텀 비즈니스 로직을 처리· Cloudflare CDN이 정적/동적 콘텐츠 가속· I’mport·카카오 API 가용성· RLS로 멀티 테넌시 보안 확보  \n\n## 2. Tech Stack\n\n| Category                | Technology / Library               | Reasoning (선택 이유)                          |\n| ----------------------- | --------------------------------- | ---------------------------------------------- |\n| Frontend Framework      | Next.js 14 (App Router)           | SSR/ISR, Server Actions로 SEO·성능 최적화       |\n| Language                | TypeScript                        | 정적 타이핑으로 안정성·생산성 확보              |\n| UI Toolkit              | Tailwind CSS                      | 유연한 유틸리티 클래스 기반 스타일링            |\n| Data Fetching           | Next.js Server Actions, SWR       | 서버-클라이언트 데이터 일관성·캐싱 활용         |\n| Localization            | next-i18next                      | 다국어 지원(한국어·영어) 간편 설정              |\n| Backend BaaS             | Supabase                          | Postgres, Auth, Storage, Realtime 통합 제공     |\n| Database                | PostgreSQL                        | 관계형 DB, RLS로 멀티 테넌시 보안              |\n| Auth & Security         | Supabase Auth (JWT, OAuth2), RLS  | 이메일·SNS 로그인, 세션 안전 관리               |\n| Real-time               | Supabase Realtime, WebSocket      | 재고·예약 현황 실시간 업데이트                  |\n| Storage                 | Supabase Storage, AWS S3 Backup   | 사용자 업로드 파일 관리, 중요 데이터 백업       |\n| Serverless Functions    | Supabase Edge Functions           | 결제, 알림, 커스텀 API 로직 경량화              |\n| CDN & Caching           | Vercel + Cloudflare CDN           | 글로벌 엣지 캐싱, 정적·동적 콘텐츠 가속          |\n| CI/CD & Hosting         | Vercel                            | 자동 배포·롤백, Preview 배포 지원               |\n| Payment Gateway         | I’mport                           | 국내 주요 결제 수단 통합                        |\n| Messaging & Notifications| Kakao Biz Message, SMS API        | 예약 알림, 체크인 리마인더                      |\n| Analytics & Monitoring  | Google Analytics 4, Sentry        | 사용자 행동 분석, 에러 모니터링                 |\n\n## 3. System Architecture Design\n\n### Top-Level Building Blocks\n- **고객용 웹 애플리케이션**  \n  Next.js 14 기반 SSR/ISR, Tailwind CSS UI  \n- **모임장 전용 콘솔 & 운영자 관리자 페이지**  \n  역할 기반 페이지 분리, RBAC 지원  \n- **백엔드 API 레이어**  \n  Supabase Edge Functions로 결제·알림·CRUD 처리  \n- **데이터 저장소**  \n  PostgreSQL(DB), Storage(이미지·파일)  \n- **실시간 서비스**  \n  Supabase Realtime + WebSocket으로 재고/예약 푸시  \n- **서드파티 연동**  \n  I’mport, Kakao Biz Message, Google Analytics  \n- **인프라 & 배포**  \n  Vercel + Cloudflare CDN + AWS S3 백업\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph LR\n  Client[웹 클라이언트] -->|HTTP/SSR| Vercel[Next.js on Vercel]\n  Vercel -->|Edge Functions| Supabase_API[Supabase Edge Functions]\n  Supabase_API --> PostgreSQL[(PostgreSQL)]\n  Supabase_API --> Auth[Supabase Auth]\n  Vercel -->|Realtime| Realtime[Supabase Realtime]\n  Supabase_API --> Storage[Supabase Storage]\n  Vercel --> CDN[Cloudflare CDN]\n  Supabase_API --> ThirdParty[결제·메시지·GA4 API]\n  AWS_S3[AWS S3] -->|백업| PostgreSQL\n```\n- 웹 클라이언트는 Next.js SSR/ISR을 통해 HTML/CSS/JS를 수신  \n- Next.js에서 호출된 Edge Functions가 비즈니스 로직 수행 후 Postgres/API 연동  \n- Realtime 구독으로 재고·예약 상태를 클라이언트에 푸시  \n- CDN(Cloudflare)이 정적 자산 및 ISR 캐싱 가속  \n- 외부 서비스(I’mport, Kakao Biz) 호출은 Edge Functions에서 처리, 로깅  \n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**  \n- **Domain Separation**: room, program, reservation, user, payment, notification, admin  \n- **Layer-Based Architecture**: presentation (pages/components), business logic (services/functions), data access (db schemas/migrations), infrastructure (config, pipeline)  \n- **Feature-Based Modules**: 각 도메인별 모듈로 묶어 재사용성 및 유지보수성 확보  \n- **Shared Components**: UI components, utils, types, hooks  \n\n**Universal File & Folder Structure**\n```\n/\n├── public\n│   └── assets/...\n├── src\n│   ├── pages\n│   │   ├── index.tsx\n│   │   ├── reservation/\n│   │   ├── admin/\n│   │   └── auth/\n│   ├── components\n│   │   └── ui/...\n│   ├── domains\n│   │   ├── room/\n│   │   ├── program/\n│   │   ├── reservation/\n│   │   ├── user/\n│   │   └── payment/\n│   ├── services\n│   │   ├── supabaseClient.ts\n│   │   ├── paymentService.ts\n│   │   └── notificationService.ts\n│   ├── utils\n│   ├── hooks\n│   ├── styles\n│   └── lib\n├── supabase\n│   ├── functions/\n│   └── migrations/\n├── vercel.json\n├── tsconfig.json\n└── package.json\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: Next.js Server Actions/API Routes → Supabase Edge Functions → 클라이언트  \n- **Database Interaction**: supabase-js ORM-like 사용, RLS 정책, 트랜잭션 처리  \n- **External Service Integration**: Edge Functions 내 재시도 로직, 백오프 전략  \n- **Real-time Communication**: Supabase Realtime 채널 구독, 클라이언트 WebSocket 수신  \n- **Data Synchronization**: 낙관적 잠금·트랜잭션·행 수준 잠금으로 재고·예약 일관성 확보  \n\n## 4. Performance & Optimization Strategy\n- Next.js ISR/SSG로 정적 페이지 캐싱, API 응답 최소화  \n- Cloudflare CDN 및 Vercel Edge Caching으로 글로벌 엣지 캐싱  \n- DB 인덱싱(date, room_id, program_id), 파티셔닝 고려  \n- 이미지·정적 리소스 최적화(Next/Image, lazy loading)  \n- SWR/React Query 등 클라이언트 캐싱, 배치 요청  \n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Vercel 프로젝트 설정, Supabase 초기 스키마·Auth  \n- **Essential Features**: 객실·프로그램 통합 예약, 결제(I’mport), 로그인·회원 시스템  \n- **Basic Security**: TLS 설정, JWT·RLS 적용  \n- **Development Setup**: CI/CD(Vercel), 코드 린팅·타입체크  \n- **Timeline**: D+0 ~ D+60 (60일)  \n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 모임장 모드(다중 객실·CSV), 마이페이지, 쿠폰 엔진  \n- **Performance Optimization**: DB 튜닝, 캐싱 전략 고도화  \n- **Enhanced Security**: 휴대폰 인증, OWASP 대응  \n- **Monitoring Implementation**: Sentry, Supabase Analytics  \n- **Timeline**: D+61 ~ D+90 (30일)  \n\n### Phase 3: Scaling & Optimization\n- **Scalability Implementation**: 멀티 테넌시, 읽기 복제본, 오토스케일  \n- **Advanced Integrations**: 추가 결제사, AI 추천 PoC  \n- **Enterprise Features**: B2B 패키지, 수요 예측  \n- **Compliance & Auditing**: GDPR, ISO, 로그 감사  \n- **Timeline**: D+91 ~ D+150 (60일)  \n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: Supabase Edge 기능 한계 → 독립 Lambda/FaaS 연동  \n- **Performance Risks**: DB 병목 → 리드 리플리카, 캐싱, 파티셔닝  \n- **Security Risks**: OAuth 토큰 유출, SQL 인젝션 → RLS, Prepared Statement  \n- **Integration Risks**: 서드파티 API 장애 → 재시도·폴백 로직, 다중 결제사  \n\n### Project Delivery Risks\n- **Timeline Risks**: 외부 연동 지연 → 초기 PoC, 병렬 개발  \n- **Resource Risks**: Next.js 14·Supabase 경험 부족 → 내부 워크숍, 문서화  \n- **Quality Risks**: 테스트 미흡 → 유닛·통합 테스트 자동화  \n- **Deployment Risks**: 환경 불일치 → IaC, 스테이징 파이프라인  \n- **Contingency Plans**: Vercel 롤백, DB 백업/복원 스크립트 준비  \n\n---  \n**끝.**",
      "writedAt": "2025-07-14T15:22:24.478Z"
    },
    {
      "type": "guideline",
      "content": "# 코드 가이드라인\n\n## 1. 프로젝트 개요\n본 프로젝트는 Next.js 14(App Router), TypeScript, Tailwind CSS를 프론트엔드에 사용하고, Supabase(PostgreSQL, Auth, Storage, Edge Functions, Realtime)를 백엔드 BaaS로 활용합니다. 인프라는 Vercel + Cloudflare CDN, AWS S3 백업 구조로 구성하여 글로벌 엣지 캐싱과 수평 확장성을 확보합니다.  \n주요 설계 결정은 다음과 같습니다.  \n- **도메인 기반 모듈화**: rooms, programs, reservations, users, payments, notification 등 도메인 단위 폴더 분리  \n- **레이어드 아키텍처**: Presentation(pages/components) → Business Logic(services/functions) → Data Access(db schemas, migrations) → Infra(config)  \n- **데이터 흐름**: Next.js Server Actions/API Routes → Supabase Edge Functions → PostgreSQL → Realtime/WebSocket 푸시\n\n## 2. 핵심 원칙\n1. 책임 분리(Separation of Concerns): 한 파일·함수는 하나의 역할만 수행해야 함.  \n2. 타입 안정성(Type Safety): 모든 변수·함수에 명시적 타입 선언, `strict` 모드 유지.  \n3. 일관된 코드 스타일(Consistency): Prettier·ESLint 규칙 준수 및 커스텀 룰 적용.  \n4. 예외 처리 표준화(Error Handling): 서비스 계층에 `try/catch` + 중앙 로깅/알림 필수.  \n5. 재사용성·확장성(Modularity): 공용 컴포넌트∙훅∙유틸은 `src/shared`에 집중 관리.\n\n## 3. 언어별 가이드라인\n\n### 3.1 Next.js + TypeScript\n- 파일 조직  \n  - `src/pages/(auth|reservation|admin)/…`  \n  - `src/app/(공용 컴포넌트)/…`  \n  - `src/components/ui/…`, `src/domains/…`, `src/shared/…`  \n- 임포트 관리  \n  - 절대경로(`tsconfig.json` `paths`) 사용: `import { fetchRooms } from 'domains/room/service'`  \n  - 함수·컴포넌트는 named export, 페이지는 default export 허용  \n- 에러 처리 패턴  \n  - Server Action 내 `try { … } catch (error) { logError(error); throw new Error('예약 실패') }`  \n  - 클라이언트는 `.catch()` 또는 `useSWR` `onError` 핸들러로 처리\n\n### 3.2 Supabase Edge Functions (Node.js + TypeScript)\n- 파일 조직  \n  - `supabase/functions/[domain]/[action].ts` (예: `supabase/functions/payment/process.ts`)  \n- 환경변수  \n  - `Deno.env.get('SUPABASE_URL')` 등 Deno 방식 사용, 누출 금지  \n- 에러 처리  \n  - HTTP 응답에 `status: number`, `message: string` 명시  \n  - 재시도 로직: `await retry(async () => { … }, { retries: 3, factor: 2 })`\n\n### 3.3 Tailwind CSS\n- 파일 조직  \n  - `src/styles/tailwind.css` + `tailwind.config.js`  \n- 클래스 네이밍  \n  - 유틸리티만 사용, 커스텀 클래스 최소화  \n  - `@apply`는 컴포넌트 단위로만 허용  \n- 반응형  \n  - `sm:`, `md:`, `lg:` 프리픽스 표준화\n\n## 4. 코드 스타일 규칙\n\n### MUST Follow\n1. **strict 모드 유지**  \n   rationale: 타입 안전성 확보  \n   ```typescript\n   // tsconfig.json\n   {\n     \"compilerOptions\": {\n       \"strict\": true,\n       \"noImplicitAny\": true,\n       \"strictNullChecks\": true\n     }\n   }\n   ```\n2. **도메인별 폴더 분리**  \n   rationale: 높은 응집도, 낮은 결합도  \n   ```bash\n   src/\n   ├─ domains/\n   │  ├─ room/\n   │  │  ├─ service.ts\n   │  │  └─ types.ts\n   ```\n3. **Server Action + Form 사용**  \n   rationale: 데이터 일관성, CSRF 방어  \n   ```typescript\n   // src/app/reserve/page.tsx\n   'use server';\n   import { createReservation } from 'domains/reservation/service';\n   \n   export async function POST(formData: FormData) {\n     try {\n       const data = Object.fromEntries(formData);\n       return await createReservation(data);\n     } catch (e) {\n       console.error(e);\n       return new Response('예약 실패', { status: 500 });\n     }\n   }\n   ```\n4. **SWR for Data Fetching**  \n   rationale: 캐싱·재검증  \n   ```typescript\n   import useSWR from 'swr';\n   const fetcher = (url: string) => fetch(url).then(res => res.json());\n   export function useRooms() {\n     return useSWR('/api/rooms', fetcher);\n   }\n   ```\n5. **Tailwind @apply은 컴포넌트 전용**  \n   rationale: 중복 방지, 유지보수 용이  \n   ```css\n   /* src/styles/button.css */\n   .btn-primary {\n     @apply bg-blue-600 text-white px-4 py-2 rounded;\n   }\n   ```\n\n### MUST NOT Do\n1. **대규모 모듈 정의 금지**  \n   - 하나의 파일에 여러 도메인 로직 작성 금지  \n   - ⇒ 기능별 파일 분리  \n2. **`any` 사용 금지**  \n   - 타입이 불명확하면 제네릭·유틸 타입 활용  \n3. **인라인 스타일(tailwind class 제외) 금지**  \n   - 유지보수성 저하  \n4. **console.log 실 운행 코드 금지**  \n   - 디버그용 logger 또는 Sentry 사용  \n5. **DB 호출 직접 컴포넌트 내 구현 금지**  \n   - 반드시 서비스 계층 통해 호출  \n   ```typescript\n   // ❌ 직접 호출\n   const { data } = await supabase.from('rooms').select('*');\n   // ✅ 서비스 분리\n   import { fetchAllRooms } from 'domains/room/service';\n   const rooms = await fetchAllRooms();\n   ```\n\n## 5. 아키텍처 패턴\n\n### 모듈 구조 가이드\n- `src/domains/{domain}/{service|controller|types}.ts`  \n- `src/shared/{components|hooks|utils}`  \n\n### 데이터 흐름\n1. **프레젠테이션**: Next.js 페이지/컴포넌트 →  \n2. **비즈니스 로직**: `domains/*/service.ts` →  \n3. **데이터 액세스**: `supabaseClient` → PostgreSQL →  \n4. **실시간 푸시**: Supabase Realtime 채널\n\n### 상태 관리\n- 읽기: `useSWR`  \n- 쓰기: Next.js Server Actions 또는 Edge Functions 호출  \n- 글로벌 상태 불필요; 공용 상태는 React Context 최소 사용\n\n### API 설계 기준\n- RESTful 규칙 준수(`/api/reservations/[id]`)  \n- HTTP 메서드 정확히 매핑: GET(조회), POST(생성), PUT/PATCH(수정), DELETE(삭제)  \n- 응답 구조 통일 `{ success: boolean; data?: T; error?: string }`\n\n## 예시 코드 스니펫\n\n```typescript\n// MUST: 서비스 계층 분리\n// domains/reservation/service.ts\nimport { supabase } from 'shared/supabaseClient';\nexport type ReservationInput = { roomId: string; date: string; count: number };\n\nexport async function createReservation(input: ReservationInput) {\n  const { data, error } = await supabase\n    .from('reservations')\n    .insert({ room_id: input.roomId, date: input.date, count: input.count });\n  if (error) throw new Error(error.message);\n  return data;\n}\n```\n\n```typescript\n// MUST NOT: 컴포넌트에서 직접 DB 호출\n// src/app/reserve/page.tsx\n'import { supabase } from 'shared/supabaseClient';\n\nexport default async function Page() {\n  // ❌ NG: 프레젠테이션 계층에서 직접 호출\n  const { data } = await supabase.from('reservations').select('*');\n  return <div>{data.length}건 예약</div>;\n}\n```\n\n```typescript\n// MUST: Server Action + 예외 처리\n'use server';\nimport { createReservation } from 'domains/reservation/service';\n\nexport async function POST(formData: FormData) {\n  try {\n    const payload = Object.fromEntries(formData) as any;\n    const reservation = await createReservation(payload);\n    return new Response(JSON.stringify({ success: true, data: reservation }), {\n      status: 200,\n    });\n  } catch (e) {\n    console.error(e);\n    return new Response(JSON.stringify({ success: false, error: e.message }), {\n      status: 500,\n    });\n  }\n}\n```\n\n```typescript\n// MUST NOT: any 사용\nfunction process(data: any) {\n  // ❌ NG: any\n  console.log(data);\n}\n// ✅ 제네릭 활용\nfunction process<T>(data: T): T {\n  console.log(data);\n  return data;\n}\n```",
      "writedAt": "2025-07-14T15:22:24.478Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-14T15:22:24.478Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-07-14T15:22:24.478Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-14T15:22:24.478Z"
    }
  ]
}